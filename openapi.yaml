openapi: "3.0.3"
info:
  description: > 
    This API provides users with a variety of algorithms of approximating the optimum route through a set of points (in 2-D, 3-D, or a graph).
    The request from the user provides the points and the algorithms they want to use, along with any algorithm-specific configuration information.
    The response contains an ordered array of points according to the best approximation produced in accordance with the request's parameters.
  version: "0.1.0"
  title: "TSP Solver"
  contact:
    name: Lee Heustis
    url: https://www.linkedin.com/in/lee-heustis-08b61929/
  license:
    name: "MIT"
    url: "https://opensource.org/licenses/MIT"
externalDocs:
  description: "TSP Solver library source code"
  url: "https://github.com/heustis/tsp-solver-go"
servers:
- url: https://replace.me
  description: > 
    TODO - anyone deploying this API in their own environment should replace this server with the appropriate information.
    If you have multiple environments, create one entry in this servers list for each environment (or use OpenAPI variables).
paths:
  /tsp/solve/v1:
    post:
      summary: "Find the approximate best circuit through a set of points."
      description: > 
        The request provides the points (in 2-D, 3-D, or a graph) and the algorithms that should be used to approximate the best circuit, along with any algorithm-specific configuration information.
        The response contains the supplied points in an ordered array, so that travelling from index-0 to index-1, to index-2, ..., and finally from index-n to index-0 produces the shortest length circuit (based on the request's parameters).
      operationId: "solveTsp"
      requestBody:
        required: true
        description: "The points (in 2-D, 3-D, or a graph) and the algorithms that should be used to approximate the best circuit, along with any algorithm-specific configuration information."
        content:
          'application/json':
            schema:
              $ref: "#/components/schemas/TspRequest"
      responses:
        "200":
          description: "Success"
          content:
            'application/json':
              schema:
                $ref: "#/components/schemas/TspResponse"
        "400":
          description: "Bad Request"
      security:
      - tsp_auth:
        - "write:tsp"
components:
  securitySchemes:
    tsp_auth:
      type: "oauth2"
      description: "TODO - deploying this API in their own environment should replace this security scheme with the appropriate information"
      flows: 
        implicit:
          authorizationUrl: "https://oauth2.replace.me/"
          scopes:
            write:tsp: "modify pets in your account"
  schemas:
    TspRequest:
      type: object
      description: "A request to the /tsp/solve/v1 endpoint contains the set of unordered points that define where the circuit must pass through, along with the algorithm that should be used to approximate the circuit."
      allOf:
        - type: object
          description: "Wrapper for the algorithms array in requests to the /tsp/solve/v1 endpoint."
          properties:
            algorithms:
              type: array
              description: "The algorithms that will be used to approximate the optimum circuit. If no algorithms are supplied, AlgorithmClosestGreedy will be used. If multiple algorithms are supplied, each will be computed independently, and only the best result will be returned."
              items:
                $ref: "#/components/schemas/Algorithm"
        - oneOf:
          - $ref: "#/components/schemas/Points2DArray"
          - $ref: "#/components/schemas/Points3DArray"
          - $ref: "#/components/schemas/PointsGraphArray"
          discriminator:
            propertyName: pointType
    TspResponse:
      type: object
      description: "The best computed approximation of the optimum route through a set of points, as returned by the /tsp/solve/v1 endpoint. The points in the response array are ordered according to when they should be visited in that approximation. The starting point may not be at index 0."
      oneOf:
      - $ref: "#/components/schemas/Points2DArray"
      - $ref: "#/components/schemas/Points3DArray"
      - $ref: "#/components/schemas/PointsGraphArray"
    Algorithm:
      type: object
      description: |
        The types of algorithms used to approximate the optimum circuit through a set of points.  
        See each algorithm's description for an overview of how they work, as well as this project's README for an analysis of performance and accuracy of each algorithm.
      oneOf:
      - $ref: "#/components/schemas/AlgorithmClosestClone"
      - $ref: "#/components/schemas/AlgorithmClosestGreedy"
      - $ref: "#/components/schemas/AlgorithmDisparityClone"
      - $ref: "#/components/schemas/AlgorithmDisparityGreedy"
      - $ref: "#/components/schemas/AlgorithmGenetic"
      - $ref: "#/components/schemas/AlgorithmSimulatedAnnealing"
      discriminator:
        propertyName: algorithmType
        mapping:
          ANNEALING: "#/components/schemas/AlgorithmSimulatedAnnealing"
          CLOSEST_CLONE: "#/components/schemas/AlgorithmClosestClone"
          CLOSEST_GREEDY: "#/components/schemas/AlgorithmClosestGreedy"
          DISPARITY_CLONE: "#/components/schemas/AlgorithmDisparityClone"
          DISPARITY_GREEDY: "#/components/schemas/AlgorithmDisparityGreedy"
          GENETIC: "#/components/schemas/AlgorithmGenetic"
    AlgorithmClosestClone:
      type: object
      description: |
        This behaves similarly to AlgorithmClosestGreedy, in that it first builds a convex hull _(optimum for 2D, an approximation for 3D and graphs)_, then selects interior points to attach to the hull based on whichever point has the minimum distance increase. 
        
        The difference is that, unlike AlgorithmClosestGreedy, this clones the entire circuit either whenever a point would be attached to a location, or whenever an attached point would be reattached at a different location. This allows this algorithm to explore possibilities that would be missed by the greedy algorithm. 
        
        To enable this behavior, this algorithm tracks each point and its distances to each edge in the circuit, exluding edges that the point has already been attached to. When comparing the the effect of attaching a point to the circuit, on the length of the circuit, both the distance increase of the new location and the distance decrease of removing the existing location are taken into account.
      properties:
        algorithmType:
          type: string
          enum:
            - "CLOSEST_CLONE"
          example: "CLOSEST_CLONE"
          description: "Specifies the type of algorithm to be used."
        cloneOnFirstAttach:
          type: boolean
          default: false
          example: true
          description: |
            True indicates that each time a point is attached to the circuit, a new clone should be created.
            
            False, or missing, indicates that a clone should only be created if the point being attached to the circuit was already attached earlier.
        maxClones:
          type: integer
          format: int64
          default: -1
          example: 10000
          description: |
            The maximum number of clones that should be created during this algorithm.
            When choosing which clones to retain, this will prefer circuits that are closer to completion as well as shorter circuits.
            
            - If this value is missing or less than 1, the number of clones will not be limited.  
            - If the number of clones is too high, there is a risk of running out of memory on the server/lambda/etc.   
            _Note: the amount of memory used is a function of the number of points, type of points (2D, 3D, graph), and maximum number of clones._  
            - As the number of clones is lowered, the number of explored solutions is also lowered (increasing the risk that an optimum will be missed, but improving performance).
      required:
      - algorithmType
    AlgorithmClosestGreedy:
      type: object
      description: |
        This algorithm:  
        1. builds a convex hull surrounding the points _(optimum for 2D, an approximation for 3D and graphs)_,  
            a. Compute the midpoint of all the points.  
            b. Finds the point farthest from the midpoint.  
            c. Finds the point farthest from the point in 1a.  
            d. Creates initial edges 1b->1c and 1c->1b _(note: all other points are exterior at this time)_  
            e. Finds the exterior point farthest from its closest edge and attach it to the circuit by splitting its closest edge.  
            f. Find any points that were external to the circuit and are now internal to the circuit, and stop considering them for future iterations.  
            g. Repeat 1e and 1f until all points are attached to the circuit or internal to the circuit.
        2. tracks each unattached point and its the closest edge,  
        3. selects the point that increases the length of the circuit the least, when attached to its closest edge,  
        4. attaches the point from step 3 to the circuit,  
        5. updates the closest edge for all remaining unattached points, to account for splitting an existing edge into two new edges,  
        6. repeats steps 3-5 until all points are attached to the circuit.
      properties:
        algorithmType:
          type: string
          enum:
            - "CLOSEST_GREEDY"
          example: "CLOSEST_GREEDY"
          description: "Specifies the type of algorithm to be used."
        cloneByInitEdges:
          type: boolean
          default: false
          example: true
          description: |
            True will cause the algorithm to perform 'E' parallel computations of the greedy algorithm, where 'E' is the number of edges in the convex hull. It does this by cloning the circuit once per convex hull edge, and attaching that edge to its closest interior point. This allows the greedy algorithm to detect edge cases it may otherwise miss.
            
            False, or missing, indicates that this additional computation should not occur.
        updateInteriorPoints:
          type: boolean
          default: false
          example: true
          description: |
            True will cause the algorithm, in step 5, to also check all attached interior points, to see if either of the newly created edges is closer to the attached point than the edge it was initially attached to. If one of the new edges is closer to the point than its current location, it will be detached from the circuit, so that it can be reattached at a more optimal location (either the new edge, or another closer edge that is created between this iteration and when the detached point is next processed).
            
            False, or missing, indicates that this additional computation should not occur.
      required:
      - algorithmType
    AlgorithmDisparityClone:
      description: |
         This behaves similarly to AlgorithmDisparityGreedy in that it first builds a convex hull and then it prioritizes points based on the disparity in distance increases from those points to the edges. However, unlike the greedy algorithm, this will clone the circuit if a point is close to multiple edges, and attach it to each of those edges.
         
         To determine whether a gap is significant, this computes the following statistics for each point (in each clone):  
         * the average gap in distance increases
         * and standard deviation of the gaps
         
         When selecting which point to attach next, this first finds the earliest significant gap. If multiple points have significant gaps at the same position, the most significant gap of those is chosen. For example:
         * Point A has distance increases of 2, 3, 10, 12, ... (gaps 1, 7, 2, ...)
         * Point B has distance increases of 1, 7, 8, 10, ... (gaps 6, 1, 2, ...)
         * Point C has distance increases of 1, 2, 6, 7, ... (gaps 1, 4, 1, ...)
         * Point B will be chosen first since its significant gap is at the 0th index
         * Point A will be chosen second since it and C have significant gaps at the 1st index, but A's is more significant.  
         * Since point A's gap is after two edges, the current circuit will be cloned into two circuits (incliding the current circuit), each with point A attaching a different one of those edges.  
         * If point A were after three edges, three circuits would be created/updated (including the initial circuit).
         
         Note: unlike AlgorithmClosestClone once a point is attached to a circuit, that point is not allowed to move.
      type: object
      properties:
        algorithmType:
          type: string
          enum:
            - "DISPARITY_CLONE"
          example: "DISPARITY_CLONE"
          description: "Specifies the type of algorithm to be used."
        maxClones:
          type: integer
          format: uint16
          default: 65535
          example: 10000
          description: |
            The maximum number of clones that should be created during this algorithm.
            When choosing which clones to retain, this will prefer circuits that are closer to completion as well as shorter circuits.
            
            - If this value is missing, less than 1, or more than 65535, the number of clones will be limited to 65535.  
            - If the number of clones is too high, there is a risk of running out of memory on the server/lambda/etc.   
            _Note: the amount of memory used is a function of the number of points, type of points (2D, 3D, graph), and maximum number of clones._  
            - As the number of clones is lowered, the number of explored solutions is also lowered (increasing the risk that an optimum will be missed, but improving performance).
        minSignificance:
          type: number
          format: double
          default: 1.0
          example: 1.5
          description: |
            The Z-score _(number of standard deviations from the mean)_ that a gap has to have, relative to other gaps for that point, to be considered significant. This must be greater than 0, since we are only considering larger than average gaps.  
            Note: This is effectively a one-sided/one-tailed test, since we are only looking for significantly large gaps.
      required:
      - algorithmType
    AlgorithmDisparityGreedy:
      type: object
      description: |
        This behaves similarly to AlgorithmClosestGreedy, except this algorithm selects points based on the gap in distance increase between a point's two closest edges, rather than minimizing the circuit length increase. This changes the information tracked in steps 2 and 5, as well as the selection process in step 3.
        
        For example:  
        * point A has distance increases of 5 and 10 to its closest edges,  
        * point B has distance increases of 4 and 6 to its closest edges,  
        * this algorithm will select point A before B, since A's gap in distance increases if 5, whereas B's is 2
        
        To understand why this works, consider the locations where an unattached point can be within a circuit: 
        1. near a single edge,
            * This will have a significant disparity between the distance increase of its closest edge, and the distance increase of all other edges.
        2. near a corner of two edges,
            * This will have an insignificant disparity between the distance increase of the two corner edges, and but a significant disparity between those two edges and the distance increase of all other edges.
        3. in the middle of several edges,
            * The number of edges with an insignificant disparity is typically greater than two, but is more variable than the other locations.
        
        This algorithm prioritizes category 1 points, since their closest edge is likely to be their optimum location, and defers processing category 2 points, which are harder to predict the optimum location.
        
        As points are attached to the circuit, points in category 3 will move into categories 1 and 2 due to concave edges becoming closer to them than the initial convex edges were. Some points may become external points, since this doesn't prioritize the closest points, but that is okay as the closest edge to any of those points will be one of the new edges (so it won't create intersecting edges).
        
        Eventually category 2 points need to be selected, but the earlier selections should improve the accuracy of these selections and reduce the impact of incorrect selections on the length of the circuit.
      properties:
        algorithmType:
          type: string
          enum:
            - "DISPARITY_GREEDY"
          example: "DISPARITY_GREEDY"
          description: "Specifies the type of algorithm to be used."
        useRelativeDisparity:
          type: boolean
          default: false
          example: true
          description: |
            True will cause this algorithm to compute disparity by dividing the larger distance increase by the smaller distance increase.  
            False, or missing, indicates that the disparity should be computed by subtracting the smaller distance increase from the larger distance increase.
      required:
      - algorithmType
    AlgorithmGenetic:
      type: object
      description: |
        This implements a [genetic algorithm](https://en.wikipedia.org/wiki/Genetic_algorithm) to stochastically approximate the optimum circuit through a set of points. 
        
        Unlike the convex-concave algorithms (both closest and disparity variants) this does not start from a convex hull and work towards a completed circuit. Rather this starts with a randomly generated set of circuits, mutates them to create new circuits, and repeats this process a number of times. Returning the best circuit found during this process.
        
        The detailed breakdown of how this works is:
        1. Initialization - a random set of parent circuits are created. By default these are random circuits, but users can optionally have the circuits based on the optimum convex hull.
        2. Child circuits are created by:
              1. Randomly selecting two parent circuits.
              2. Using crossover to blend the parent circuits into a new circuit.
              3. Fixing any duplicate or missing points that result from the crossover.
              4. Mutating the circuit (as described in "mutationRate")
        3. Selection - this uses an elitist slection algorithm, to ensure that the best solutions are not lost from one generation to the next. To do this the new children are combined with the previous generation of parents, and the top "numParents" (based on shortest circuit length) are retained for the next iteration.
        4. Termination - this repeats steps 2 and 3 "maxIterations" times, then returns the best circuit found by this process.
      properties:
        algorithmType:
          type: string
          enum:
            - "GENETIC"
          example: "GENETIC"
          description: "Specifies the type of algorithm to be used."
        maxCrossovers:
          type: integer
          format: int64
          example: 10
          description: |
            The maximum number of times that a crossover should occur when creating a child circuit. The number of crossovers for any child will be random [1, maxCrossovers) (unless this is 1, since there will always be at least 1 crossover).  
            If not present, this defaults to one less than the number of points in the circuit.  
            Minimum (inclusive): 1  
            Maximum (exclusive): number of points in the circuit
        maxIterations:
          type: integer
          format: int64
          example: 100
          description: |
            The number of time to repeat the process of creating/mutating children, and selecting the next generation of parents.
        mutationRate:
          type: number
          format: double
          default: 0.1
          example: 0.75
          description: |
            The mutation rate is the percentage chance that any given index in the circuit will be mutated when creating a child circuit. To clarify:
            * after completing the crossover phase of the genetic algorithm,
            * each point in the circuit will be given a "mutationRate" percent chance of being mutated,
            * a random number (0.0 to 1.0) will be generated for each point,
            * any point with a random number less than the mutation rate will swap with a random point on the circuit (regardless of the other point's random number)
            
            This must be between 0.0 (0% chance of mutation) and 1.0 (100% chance of mutation).  
        numChildren:
          type: integer
          format: int64
          example: 1000
          description: |
            The number of children (new circuits) to create each iteration.
            Minimum (inclusive)=1
            
            - If the number of children is too high, there is a risk of running out of memory on the server/lambda/etc.   
            _Note: the amount of memory used is a function of the number of points, type of points (2D, 3D, graph), number of parents, and number of children._  
            - As the number of children is lowered, the number of explored solutions is also lowered (increasing the risk that an optimum will be missed, but improving performance).
        numParents:
          type: integer
          format: int64
          example: 500
          description: |
            The number of circuits to retain during the [selection](https://en.wikipedia.org/wiki/Selection_\(genetic_algorithm\)) phase of each iteration.
            Prior to the first iteration, this many random circuits will be generated to act as initial parents for the first circuit.
            Minimum (inclusive)=1
            
            - If the number of parents is too high, there is a risk of running out of memory on the server/lambda/etc.   
            _Note: the amount of memory used is a function of the number of points, type of points (2D, 3D, graph), number of parents, and number of children._  
            - As the number of parents is lowered, the number of explored solutions is also lowered (increasing the risk that an optimum will be missed, but improving performance).
        seed:
          type: integer
          format: int64
          example: 1234
          description: |
            The seed used by the genetic algorithm to randomize selection of parents, crossover points, and mutations. This should be used during integration tests where the result of this algorithm must be consistent.
        shouldBuildConvexHull:
          type: boolean
          default: false
          example: true
          description: |
            True indicates that the initial set of parents will first have a convex hull built, then have unattached points randomly distributed along the hull. This can produce a more accurate set of initial parents than randomly creating circuits through the points.

            False indicates that the initial set of parents will be random circuits through the points.
      required:
      - algorithmType
      - maxIterations
      - numChildren
      - numParents
    AlgorithmSimulatedAnnealing:
      type: object
      description: |
        This implements [simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing) to stochastically approximate the optimum circuit through a set of points. 
        
        Unlike the convex-concave algorithms (both closest and disparity variants) this does not start from a convex hull and work towards a completed circuit. Rather this treats the supplied set of points as the initial circuit, or uses another algorithm to create an initial circuit, and mutates its to try to find a better sequencing of points for the circuit.
        
        During each iteration (up to "maxIterations" times) this:
        1. Randomly selects 2 points.
            * If enabled, when selecting a second point it will prefer points that are close to the first selected point.
        2. Determine how swapping the 2 points impacts the circuit length.
            * i.e. how much does swapping the points lengthen or shorten the circuit?
        3. Scale this value based on the size of the coordinate space being used, so that it is meaningful regardless of if the coordinates are from -100 to +100 or -100000 to +100000
        4. Use the configured temperature function to determine the acceptance value (based on the number of iterations, max iterations, and impact of the swap).
            * The temperature function is designed to reduce the probability of accepting a "bad" swap as the number of iterations approaches the maximum iterations. This allows early swaps to avoid local maxima, but later swaps focus on refining the current circuit towards its local maximum.
        5. Generate a random number between [0.0, 1.0) as a test value.
        6. Swap the points the test value it is less than the acceptance value, or if the swap would shorten the circuit.
      properties:
        algorithmType:
          type: string
          enum:
            - "ANNEALING"
          example: "ANNEALING"
          description: "Specifies the type of algorithm to be used."
        maxIterations:
          type: integer
          format: int64
          example: 100
          description: |
            The number of time to repeat the process of mutating the circuit.
        precursorAlgorithm:
          type: object
          allOf:
          - $ref: "#/components/schemas/Algorithm"
          description: |
            The algorithm that should be used to generate the inital circuit for simulated annealing.
            If this is not specified, the points will be treated as an ordered circuit.
          example:
            algorithmType: "CLOSEST_GREEDY"
        preferCloseNeighbors:
          type: boolean
          default: false
          example: true
          description: |
            True indicates that when selecting a second point, points that are close to the first point should be prefered to points farther from the first point.

            False indicates that all points should have an equal chance of being selected as the second point regardless of proximity to the first point.
        seed:
          type: integer
          format: int64
          example: 1234
          description: |
            The seed used by the simulated annealing to randomize selection of points and generation the test value. This should be used during integration tests where the result of this algorithm must be consistent.
        temperatureFunction:
          type: string
          enum:
            - "LINEAR"
            - "GEOMETRIC"
          default: "LINEAR"
          example: "GEOMETRIC"
          description: |
            Specifies how the temperature function should account for the percent of iterations that have been completed. 
            
            The supported functions are _(t' is the next temperature, t is the current temperature, X is 1/maxIterations)_:
            * LINEAR - t'=t-X
            * GEOMETRIC -  t'=t*X
      required:
      - algorithmType
      - maxIterations
    Point2D:
      type: object
      description: "A point in 2-dimensional space"
      properties:
        x:
          type: number
          format: double
          example: 1.2
        y:
          type: number
          format: double
          example: 3.456789
      required:
      - x
      - y
    Points2DArray:
      type: object
      description: >
        An array of 2-dimensional points that should be included in the circuit.
        In the request, the points can be in any order.
        In the response the points are ordered to produce the shortest computed circuit.
      properties:
        points2d:
          type: array
          items:
            $ref: "#/components/schemas/Point2D"
          example:
          - x: 1.23
            y: 2.34
          - x: 3.45
            y: 4.56
          - x: -1.23
            y: 2.34
          - x: 15.0
            y: 0.00123
      required:
      - points2d
    Point3D:
      type: object
      description: "A point in 3-dimensional space"
      properties:
        x:
          type: number
          format: double
          example: 1.23
        y:
          type: number
          format: double
          example: 4.56000001
        z:
          type: number
          format: double
          example: 7.89
      required:
      - x
      - y
      - z
    Points3DArray:
      type: object
      description: >
        An array of 3-dimensional points that should be included in the circuit.
        In the request, the points can be in any order.
        In the response the points are ordered to produce the shortest computed circuit.
      properties:
        points3d:
          type: array
          items:
            $ref: "#/components/schemas/Point3D"
          example:
          - x: 1.23
            y: 2.34
            z: 0.34
          - x: 3.45
            y: 4.56
            z: -5.67
          - x: -1.23
            y: 2.34
            z: 12.34
          - x: 15.0
            y: 0.00123
            z: 0.0
      required:
      - points3d
    PointGraph:
      type: object
      description: > 
        A point in a graph of points, with distances to its neighbors.
        There must be a path through the graph from each point to each other point in order for the circuit to be solveable. This requires that each point has at least one neighbor.
        If a distance is supplied to one of its neighbors, that distance should be the optimum distance from this point to that neighbor point.
        The neighbor distances are treated as asymmetric, so two neighbors can have different distances to each other. Similarly, if point A has a neighbor point B, but B doesn't have a distance to A, the path from B to A will be found by traversing the graph.
      properties:
        name:
          type: string
          description: > 
            The way to uniquely identify a point in the graph.
            No two points should have the same name, unless it is okay to de-duplicate them during processing.
          example: "123 Test St. Example City, AK 12345"
        neighbors:
          type: array
          description: >
            The optimum distance from this point to one or more other points in the graph.
            There must be at least 1 element in this array, and it does not need to contain all other points in the graph, only the immediate neighbors of the point.
          items: 
            $ref: '#/components/schemas/PointGraphNeighbor'
      required:
      - name
      - neighbors
    PointGraphNeighbor:
      type: object
      description: > 
        The optimum distance between one point in a graph and a neighboring point in the graph.
        The first point is known via its PointGraph object, so it is not included in this definition.
      properties:
        name:
          type: string
          description: > 
            The way to uniquely identify the neighboring point in the graph. 
            No two points should have the same name, unless it is okay to de-duplicate them during processing. 
            The name must not be empty.
          example: "125 Test St. Example City, AK 12345"
        distance:
          type: number
          format: double
          description: "The distance from the current point to the named, neighboring point. This must be greater than 0."
          example: 1234.56789000123
    PointsGraphArray:
      type: object
      description: >
        An array of points in a graph that should be included in the circuit.
        In the request, the points can be in any order.
        In the response the points are ordered to produce the shortest computed circuit.
      properties:
        points:
          type: array
          items:
            $ref: "#/components/schemas/PointGraph"
          example:
          - name: "a"
            neighbors:
            - name: "b"
              distance: 5.1
            - name: "d"
              distance: 0.25
          - name: "b"
            neighbors:
            - name: "a"
              distance: 3.999
            - name: "c"
              distance: 1.1
          - name: "c"
            neighbors:
            - name: "b"
              distance: 1.1
            - name: "d"
              distance: 10
          - name: "d"
            neighbors:
            - name: "a"
              distance: 2.2
      required:
      - pointsGraph
